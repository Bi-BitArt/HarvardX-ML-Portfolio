# ============================================
# [Cell1] Clustering on Income & Savings (3 clusters)
# ============================================
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

# Extract features
features = ["annual_income", "savings_rate"]
X_income_save = X_test_shock[features].copy()

# KMeans clustering (3 clusters)
kmeans = KMeans(n_clusters=3, random_state=42)
clusters = kmeans.fit_predict(X_income_save)

# Add results to dataframe
X_income_save["Cluster"] = clusters

# Visualization
plt.figure(figsize=(8,6))
for cluster in range(3):
    subset = X_income_save[X_income_save["Cluster"] == cluster]
    plt.scatter(subset["annual_income"], subset["savings_rate"], label=f"Cluster {cluster}", alpha=0.6)

# Show cluster centroids
centers = kmeans.cluster_centers_
plt.scatter(centers[:,0], centers[:,1], c="black", s=200, marker="X", label="Centroids")

plt.xlabel("Annual Income")
plt.ylabel("Savings Rate")
plt.title("Clustering by Income & Savings Rate (3 clusters)")
plt.legend()
plt.show()


# ============================================
# [Cell2] Feature differences for a chosen cluster (example: Cluster 1)
# ============================================
import numpy as np

cluster1 = X_test_shock[clusters == 1]

cluster1_mean = cluster1.mean()
overall_mean = X_test_shock.mean()

diff = (cluster1_mean - overall_mean).sort_values(ascending=False)

top_features = diff.head(10)

plt.figure(figsize=(8,6))
colors = ["red" if v > 0 else "blue" for v in top_features.values]
top_features.plot(kind="barh", color=colors)
plt.title("Cluster 1 (Low Income × Low Savings) - Top Feature Differences")
plt.xlabel("Difference from Overall Mean")
plt.gca().invert_yaxis()
plt.show()


# ============================================
# [Cell3] Cluster-based Policy (Budget = 100,000 JPY × 3000 Households)
# ============================================
import numpy as np
import pandas as pd
from sklearn.cluster import KMeans

def fit_income_savings_clusters(X_train, n_clusters=3,
                                income_col="annual_income", savings_col="savings_rate",
                                random_state=42):
    Xk = X_train[[income_col, savings_col]].copy()
    kmeans = KMeans(n_clusters=n_clusters, n_init=10, random_state=random_state)
    kmeans.fit(Xk)
    return kmeans


def pick_vulnerable_cluster(kmeans, X_ref,
                            income_col="annual_income", savings_col="savings_rate"):
    labels = kmeans.predict(X_ref[[income_col, savings_col]])
    df = X_ref[[income_col, savings_col]].copy()
    df["cluster"] = labels
    grp = df.groupby("cluster")[[income_col, savings_col]].mean()
    vuln_cluster = (grp.rank(ascending=True).sum(axis=1)).idxmin()
    return labels, vuln_cluster


def apply_cluster_multidim_policy(
    X_after_shock,
    kmeans, vuln_cluster,
    income_col="annual_income", savings_col="savings_rate"
):
    """
    Total budget = 100,000 JPY × 3000 households = 300,000,000 JPY.
    Distributed within the vulnerable cluster based on need score.
    Income is normalized (1.0 = 5,000,000 JPY).
    """
    Xp = X_after_shock.copy()
    total_budget = 100_000 * 3000
    labels = kmeans.predict(Xp[[income_col, savings_col]])
    mask = (labels == vuln_cluster)
    if mask.sum() == 0:
        return Xp, labels

    def norm_series(s):
        s = s.astype(float)
        mn, mx = s.min(), s.max()
        return (s - mn) / (mx - mn + 1e-9)

    w = {"income": 0.35, "savings": 0.25, "dti": 0.25, "finlit": 0.15}

    need = pd.Series(0.0, index=Xp.index)
    if income_col in Xp.columns:
        need += w["income"] * (1.0 - norm_series(Xp[income_col]))
    if savings_col in Xp.columns:
        need += w["savings"] * (1.0 - norm_series(Xp[savings_col]))
    if "debt_to_income" in Xp.columns:
        need += w["dti"] * norm_series(Xp["debt_to_income"])
    if "financial_literacy" in Xp.columns:
        need += w["finlit"] * (1.0 - norm_series(Xp["financial_literacy"]))

    need_v = need.where(mask, other=0.0)
    need_sum = need_v.sum()

    if need_sum <= 0:
        grants = pd.Series(0.0, index=Xp.index)
        grants[mask] = total_budget / mask.sum()
    else:
        grants = total_budget * (need_v / need_sum)

    if income_col in Xp.columns:
        Xp[income_col] = Xp[income_col].astype(float) + (grants / 5_000_000.0)
        Xp[income_col] = Xp[income_col].clip(lower=0)

    return Xp, labels


# ====== Run end-to-end ======
kmeans = fit_income_savings_clusters(X_train, n_clusters=3,
                                     income_col="annual_income", savings_col="savings_rate")

labels_shock, vuln_cluster = pick_vulnerable_cluster(
    kmeans, X_test_shock, income_col="annual_income", savings_col="savings_rate"
)
print("Vulnerable cluster id:", vuln_cluster)

X_policy_cluster, labels_after = apply_cluster_multidim_policy(
    X_test_shock, kmeans, vuln_cluster,
    income_col="annual_income", savings_col="savings_rate"
)

res_cluster_policy = eval_policy_shift(
    model,
    X_test_shock,
    X_policy_cluster,
    y_test,
    label="Cluster-based (total ¥300M)"
)

import seaborn as sns
def heatmap_full_classes(trans_df, title, fname=None):
    idx = np.arange(5)
    trans_df = trans_df.copy()
    trans_df = trans_df.reindex(index=idx, columns=idx, fill_value=0.0)
    plt.figure(figsize=(6,5))
    sns.heatmap(trans_df, annot=True, fmt=".1f", cmap="Blues", cbar=False)
    plt.title(title)
    plt.xlabel("Predicted (After Policy)")
    plt.ylabel("Predicted (After Shock)")
    if fname:
        plt.tight_layout(); plt.savefig(fname, dpi=160)
    plt.show()

heatmap_full_classes(
    res_cluster_policy["trans"],
    "Class Transition Matrix (Cluster-based Policy, ¥300M total)",
    fname="cluster_policy_heatmap.png"
)
