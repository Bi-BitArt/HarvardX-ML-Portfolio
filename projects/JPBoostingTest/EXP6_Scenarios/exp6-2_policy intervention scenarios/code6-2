# ============================================================
# Household Vulnerability Policy Simulation
# Assumption: normalized income scale where 1.0 ≈ ¥5,000,000
# → Uniform cash transfer: ¥100,000 per household ≈ +0.02
# Color theme for heatmaps: Blues
# ============================================================

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.metrics import roc_auc_score, classification_report

# -----------------------------
# Global policy scale constants
# -----------------------------
SCALE_MAX_YEN = 5_000_000          # 1.0 on the normalized income scale
UNIFORM_AMOUNT_YEN = 100_000       # ¥100,000 per household
UNIFORM_AMOUNT = UNIFORM_AMOUNT_YEN / SCALE_MAX_YEN   # 0.02
TARGET_QUANTILE = 0.30             # bottom 30% targeted


# ------------------------------------------------------------
# [Common 1] Universal (Uniform) Cash Transfer
# ------------------------------------------------------------
def apply_uniform_cash_policy(
    X_df,
    income_col="annual_income",
    amount=UNIFORM_AMOUNT,
    per_capita=False,
    hhsize_col="household_size",
):
    """Apply a flat cash transfer to *normalized* income."""
    Xp = X_df.copy()
    if income_col not in Xp.columns:
        raise ValueError(f"{income_col} not found in features")

    if per_capita and (hhsize_col in Xp.columns):
        people = np.clip(Xp[hhsize_col].fillna(1), 1, None)
        Xp[income_col] = Xp[income_col] + amount * people
    else:
        Xp[income_col] = Xp[income_col] + amount
    return Xp


# ------------------------------------------------------------
# [Common 2] Targeted Cash (Bottom q)
# ------------------------------------------------------------
def apply_targeted_cash_policy(
    X_df,
    income_col="annual_income",
    amount=UNIFORM_AMOUNT,
    quantile=TARGET_QUANTILE,
):
    """Provide transfers only to households in the bottom 'quantile' by normalized income."""
    Xp = X_df.copy()
    if income_col not in Xp.columns:
        raise ValueError(f"{income_col} not found in features")
    cutoff = Xp[income_col].quantile(quantile)
    mask = Xp[income_col] <= cutoff
    Xp.loc[mask, income_col] = Xp.loc[mask, income_col] + amount
    return Xp


# ------------------------------------------------------------
# [Common 3] Budget-Neutral Targeted Cash
# ------------------------------------------------------------
def apply_budget_neutral_targeted_cash(
    X_df,
    income_col="annual_income",
    uniform_amount=UNIFORM_AMOUNT,
    quantile=TARGET_QUANTILE,
):
    """
    Redistribute total uniform budget (uniform_amount to *everyone*) to the bottom 'quantile'.
    Per-recipient transfer = uniform_amount * (1 / quantile).
    """
    Xp = X_df.copy()
    if income_col not in Xp.columns:
        raise ValueError(f"{income_col} not found in features")
    cutoff = Xp[income_col].quantile(quantile)
    mask = Xp[income_col] <= cutoff
    scale = 1.0 / quantile
    Xp.loc[mask, income_col] = Xp.loc[mask, income_col] + uniform_amount * scale
    return Xp


# ------------------------------------------------------------
# [Eval] AUC + Transition Matrix
# ------------------------------------------------------------
def eval_policy_shift(trained_model, X_base, X_policy, y_true, label="Policy"):
    """Evaluate model stability after policy (no retraining)."""
    y_prob_base = trained_model.predict_proba(X_base)
    y_prob_pol  = trained_model.predict_proba(X_policy)
    y_pred_base = y_prob_base.argmax(axis=1)
    y_pred_pol  = y_prob_pol.argmax(axis=1)

    auc_base = roc_auc_score(y_true, y_prob_base, multi_class="ovr", average="macro")
    auc_pol  = roc_auc_score(y_true, y_prob_pol,  multi_class="ovr", average="macro")

    print(f"\n== {label} ==")
    print("Baseline ROC AUC:", auc_base)
    print("After Policy ROC AUC:", auc_pol)
    print("Δ AUC:", auc_pol - auc_base)

    trans = (
        pd.crosstab(
            y_pred_base, y_pred_pol,
            rownames=["Predicted (Baseline)"],
            colnames=[f"Predicted ({label})"],
            normalize="index",
        ) * 100
    )
    print("\nTransition matrix (%):")
    print(trans.round(1))

    print("\nClassification Report (after policy):\n",
          classification_report(y_true, y_pred_pol, digits=3))

    return {"auc_base": auc_base, "auc_policy": auc_pol, "trans": trans}


# ------------------------------------------------------------
# [Viz] Heatmap (Transition Matrix, Blues)
# ------------------------------------------------------------
def plot_transition_heatmap(trans_df, title="Transition Matrix"):
    labels = sorted(list(set(trans_df.index) | set(trans_df.columns)))
    trans_df = trans_df.reindex(index=labels, columns=labels, fill_value=0.0)
    mat = trans_df.values

    fig, ax = plt.subplots(figsize=(5.8, 4.8))
    im = ax.imshow(mat, cmap="Blues", aspect="auto", vmin=0, vmax=100)
    ax.set_title(title)
    ax.set_xlabel("Predicted (After)")
    ax.set_ylabel("Predicted (Before)")
    ax.set_xticks(np.arange(len(labels)))
    ax.set_yticks(np.arange(len(labels)))
    ax.set_xticklabels(labels)
    ax.set_yticklabels(labels)
    for i in range(mat.shape[0]):
        for j in range(mat.shape[1]):
            val = mat[i, j]
            ax.text(j, i, f"{val:.1f}", ha="center", va="center",
                    color=("white" if val > 50 else "black"), fontsize=9)
    cbar = plt.colorbar(im)
    cbar.set_label("% within row", rotation=90)
    plt.tight_layout()
    plt.show()


# ============================================================
# Run policies **AFTER SHOCK**
# Base = X_test_shock (post-shock features)
# If you have y_test_shock, use it instead of y_test below.
# ============================================================

X_base = X_test_shock

# Policy 1: Uniform Cash (¥100,000 ≈ +0.02)
X_uniform_after_shock = apply_uniform_cash_policy(
    X_base, income_col="annual_income", amount=UNIFORM_AMOUNT, per_capita=False
)
res_uniform = eval_policy_shift(
    model, X_base, X_uniform_after_shock, y_test,  # replace y_test with y_test_shock if available
    label="Uniform Cash (post-shock)"
)
plot_transition_heatmap(res_uniform["trans"], "Uniform Cash")

# Policy 2: Targeted Cash (Bottom 30%, ¥100,000 to recipients)
X_targeted_after_shock = apply_targeted_cash_policy(
    X_base, income_col="annual_income", amount=UNIFORM_AMOUNT, quantile=TARGET_QUANTILE
)
res_targeted = eval_policy_shift(
    model, X_base, X_targeted_after_shock, y_test,
    label="Targeted Cash (Bottom 30%) (post-shock)"
)
plot_transition_heatmap(res_targeted["trans"], "Targeted Cash (Bottom 30%)")

# Policy 3: Budget-Neutral Targeted Cash (same total budget as uniform)
X_targeted_bn_after_shock = apply_budget_neutral_targeted_cash(
    X_base, income_col="annual_income", uniform_amount=UNIFORM_AMOUNT, quantile=TARGET_QUANTILE
)
res_targeted_bn = eval_policy_shift(
    model, X_base, X_targeted_bn_after_shock, y_test,
    label="Targeted Cash (Budget Neutral) (post-shock)"
)
plot_transition_heatmap(res_targeted_bn["trans"], "Targeted Cash (Budget Neutral)")

# ============================================================
# End of Script
# ============================================================
