# [Cell1] Define external shock function (safer & reproducible)
import numpy as np
import pandas as pd

def apply_external_shock(X_df, seed: int = 42):
    Xs = X_df.copy()

    # --- Sector-specific income shock ---
    if "sector" in Xs.columns and "annual_income" in Xs.columns:
        # Explicit mapping (adjust if necessary)
        sec_hit = {
            0: 0.75,  # heavy hit  -25%
            1: 0.75,  # heavy hit  -25%
            2: 0.85,  # medium     -15%
            3: 0.85,  # medium     -15%
            # others   -5%
        }
        factors = Xs["sector"].map(lambda s: sec_hit.get(s, 0.95))
        Xs["annual_income"] = Xs["annual_income"] * factors

        # Guard against impossible values
        Xs["annual_income"] = Xs["annual_income"].clip(lower=0)

    # --- Interest rate shock (+2pp) ---
    if "interest_rate_personal" in Xs.columns:
        Xs["interest_rate_personal"] = (Xs["interest_rate_personal"] + 0.02).clip(lower=0)

    # --- Employment shock: move 20% to more precarious category (ordinal-encoded) ---
    if "employment_status" in Xs.columns:
        rng = np.random.RandomState(seed)
        idx = rng.rand(len(Xs)) < 0.2
        # Clip at upper bound (assuming higher = more precarious)
        Xs.loc[idx, "employment_status"] = np.minimum(
            Xs.loc[idx, "employment_status"] + 1,
            Xs["employment_status"].max()
        )

    return Xs


# [Cell2] Apply shock to test set
X_test_shock = apply_external_shock(X_test, seed=42)

# [Cell3] Evaluate baseline vs shock
from sklearn.metrics import roc_auc_score

# Baseline predictions
y_pred_base = model.predict(X_test)
y_prob_base = model.predict_proba(X_test)
auc_base = roc_auc_score(y_test, y_prob_base, multi_class="ovr", average="macro")

# Shock predictions (default: use y_test as ground truth)
y_pred_shock = model.predict(X_test_shock)
y_prob_shock = model.predict_proba(X_test_shock)

# If a post-shock ground truth (y_test_shock) exists, replace it here
# y_true_for_shock = y_test_shock
y_true_for_shock = y_test

auc_shock = roc_auc_score(y_true_for_shock, y_prob_shock, multi_class="ovr", average="macro")

print("== Baseline ==")
print("ROC AUC (macro OVR):", auc_base)
print("\n== After Shock ==")
print("ROC AUC (macro OVR):", auc_shock)
print("\nΔ AUC:", auc_shock - auc_base)


# [Cell4] Transition matrix (predicted class changes in %)
trans_mat = pd.crosstab(
    y_pred_base, y_pred_shock,
    rownames=["Predicted (Baseline)"], colnames=["Predicted (Shock)"],
    normalize="index"
) * 100

print("\nTransition matrix (%):")
print(trans_mat.round(1))


# [Cell5] Prominent changes in features (concise)
def pct(x): return f"{x*100:+.1f}%"
def pp(x):  return f"{x*100:+.1f} pp"

bullets = []
delta = X_test_shock.copy() - X_test.copy()

# 1) Income: overall mean & median
if "annual_income" in X_test.columns and X_test["annual_income"].median() != 0:
    inc_base_mean = X_test["annual_income"].mean()
    inc_delta_mean = (delta["annual_income"].mean() / inc_base_mean) if inc_base_mean != 0 else 0
    inc_delta_med  = (delta["annual_income"].median() / X_test["annual_income"].median())
    bullets.append(f"annual_income: mean change {pct(inc_delta_mean)}, median change {pct(inc_delta_med)}.")

# 2) Income change by sector (worst & best)
if {"sector", "annual_income"}.issubset(X_test.columns):
    g = (X_test_shock["annual_income"] - X_test["annual_income"]).groupby(X_test["sector"]).mean()
    base_by_sec = X_test.groupby("sector")["annual_income"].mean().replace(0, np.nan)
    g_rel = (g / base_by_sec).fillna(0)
    worst_sec, best_sec = g_rel.idxmin(), g_rel.idxmax()
    bullets.append(f"By sector: worst={worst_sec} ({pct(g_rel.loc[worst_sec])}), best={best_sec} ({pct(g_rel.loc[best_sec])}).")

# 3) Employment status: share worsened
if "employment_status" in X_test.columns:
    emp_shift_up = (delta["employment_status"] > 0).mean()
    bullets.append(f"employment_status: {emp_shift_up*100:.1f}% shifted to more precarious categories.")

# 4–7) Other feature changes
for col, label in [
    ("savings_rate", "savings_rate"),
    ("late_payment_12m", "late_payment_12m"),
    ("childcare_cost_share", "childcare_cost_share"),
    ("eldercare_cost_share", "eldercare_cost_share")
]:
    if col in X_test.columns:
        bullets.append(f"{label}: average change {pp(delta[col].mean())}.")

# 8) Income change by region (worst region)
if {"region", "annual_income"}.issubset(X_test.columns):
    gr = (X_test_shock["annual_income"] - X_test["annual_income"]).groupby(X_test["region"]).mean()
    base_by_reg = X_test.groupby("region")["annual_income"].mean().replace(0, np.nan)
    gr_rel = (gr / base_by_reg).fillna(0)
    worst_reg = gr_rel.idxmin()
    bullets.append(f"By region: worst hit region={worst_reg} ({pct(gr_rel.loc[worst_reg])}).")

# 9) Foreign-born: share with worsened employment
if {"foreign_born", "employment_status"}.issubset(X_test.columns):
    mask_fb = X_test["foreign_born"] == 1
    if mask_fb.any():
        fb_worse = (delta.loc[mask_fb, "employment_status"] > 0).mean()
        bullets.append(f"foreign_born: {fb_worse*100:.1f}% experienced worsening employment status.")

# 10) Multigenerational vs non-multigenerational households
if {"multigen_household", "annual_income"}.issubset(X_test.columns):
    d_inc = (X_test_shock["annual_income"] - X_test["annual_income"])
    by_multi = d_inc.groupby(X_test["multigen_household"]).mean()
    base_means = X_test.groupby("multigen_household")["annual_income"].mean().replace(0, np.nan)
    if set(by_multi.index) >= {0,1}:
        rel0 = (by_multi.loc[0] / base_means.loc[0])
        rel1 = (by_multi.loc[1] / base_means.loc[1])
        bullets.append(f"multigen_household: income change non-multigen={pct(rel0)}, multigen={pct(rel1)}.")

print("\nChanges under shock:")
for b in bullets[:10]:
    print(f"- {b}")


# [Cell6] Visualize class changes (Matplotlib, Blues style)
import matplotlib.pyplot as plt
import numpy as np

def plot_transition_heatmap_mat(trans_df, title="Class Transition Matrix Under Shock"):
    labels = sorted(list(set(trans_df.index) | set(trans_df.columns)))
    trans_df = trans_df.reindex(index=labels, columns=labels, fill_value=0.0)
    mat = trans_df.values  # in %

    fig, ax = plt.subplots(figsize=(6, 5))
    im = ax.imshow(mat, cmap="Blues", aspect="auto", vmin=0, vmax=100)
    ax.set_title(title)
    ax.set_xlabel("Predicted (After Shock)")
    ax.set_ylabel("Predicted (Before Shock)")
    ax.set_xticks(np.arange(len(labels)))
    ax.set_yticks(np.arange(len(labels)))
    ax.set_xticklabels(labels)
    ax.set_yticklabels(labels)

    for i in range(mat.shape[0]):
        for j in range(mat.shape[1]):
            val = mat[i, j]
            ax.text(j, i, f"{val:.1f}", ha="center", va="center",
                    color=("white" if val > 50 else "black"), fontsize=9)

    cbar = plt.colorbar(im)
    cbar.set_label("% within row", rotation=90)
    plt.tight_layout()
    plt.show()

plot_transition_heatmap_mat(trans_mat, title="Class Transition Matrix Under Shock")

# ============================================================
# Household Vulnerability Policy Simulation
# Assumption: normalized income scale where 1.0 ≈ ¥5,000,000
# → Uniform cash transfer: ¥100,000 per household ≈ +0.02
# Color theme for heatmaps: Blues
# ============================================================

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.metrics import roc_auc_score, classification_report

# -----------------------------
# Global policy scale constants
# -----------------------------
SCALE_MAX_YEN = 5_000_000          # 1.0 on the normalized income scale
UNIFORM_AMOUNT_YEN = 100_000       # ¥100,000 per household
UNIFORM_AMOUNT = UNIFORM_AMOUNT_YEN / SCALE_MAX_YEN   # 0.02
TARGET_QUANTILE = 0.30             # bottom 30% targeted


# ------------------------------------------------------------
# [Code 1] Universal (Uniform) Cash Transfer
# ------------------------------------------------------------
def apply_uniform_cash_policy(
    X_df,
    income_col="annual_income",
    amount=UNIFORM_AMOUNT,
    per_capita=False,
    hhsize_col="household_size",
):
    """
    Apply a flat cash transfer to *normalized* income.
    Assumption: 1.0 ≈ ¥5,000,000, so amount=0.02 ≈ ¥100,000.
    If per_capita=True and household_size exists, give amount per person.
    """
    Xp = X_df.copy()
    if income_col not in Xp.columns:
        raise ValueError(f"{income_col} not found in features")

    if per_capita and (hhsize_col in Xp.columns):
        people = np.clip(Xp[hhsize_col].fillna(1), 1, None)
        Xp[income_col] = Xp[income_col] + amount * people
    else:
        Xp[income_col] = Xp[income_col] + amount

    return Xp



# [Code 2] Targeted Cash (Bottom q)

def apply_targeted_cash_policy(
    X_df,
    income_col="annual_income",
    amount=UNIFORM_AMOUNT,
    quantile=TARGET_QUANTILE,
):
    """
    Provide transfers only to households in the bottom 'quantile' by normalized income.
    Example: amount=0.02 ≈ ¥100,000 if 1.0 ≈ ¥5,000,000.
    """
    Xp = X_df.copy()
    if income_col not in Xp.columns:
        raise ValueError(f"{income_col} not found in features")

    cutoff = Xp[income_col].quantile(quantile)
    mask = Xp[income_col] <= cutoff
    Xp.loc[mask, income_col] = Xp.loc[mask, income_col] + amount
    return Xp


# ------------------------------------------------------------
# [Code 3] Budget-Neutral Targeted Cash
# ------------------------------------------------------------
def apply_budget_neutral_targeted_cash(
    X_df,
    income_col="annual_income",
    uniform_amount=UNIFORM_AMOUNT,
    quantile=TARGET_QUANTILE,
):
    """
    Redistribute total uniform budget (uniform_amount to *everyone*) to the bottom 'quantile'.
    Per-recipient transfer = uniform_amount * (1 / quantile).
    For example: uniform_amount=0.02, quantile=0.30 → +0.0666... for recipients.
    """
    Xp = X_df.copy()
    if income_col not in Xp.columns:
        raise ValueError(f"{income_col} not found in features")

    cutoff = Xp[income_col].quantile(quantile)
    mask = Xp[income_col] <= cutoff

    scale = 1.0 / quantile  # e.g., 1/0.30 ≈ 3.333...
    Xp.loc[mask, income_col] = Xp.loc[mask, income_col] + uniform_amount * scale
    return Xp


# ------------------------------------------------------------
# [Eval] AUC + Transition Matrix
# ------------------------------------------------------------
def eval_policy_shift(trained_model, X_base, X_policy, y_true, label="Policy"):
    """
    Evaluate model stability after policy (no retraining).
    - Computes macro OVR ROC AUC before/after policy against y_true.
    - Shows predicted-class transition matrix: baseline → post-policy.
    """
    # Probabilities and class predictions
    y_prob_base = trained_model.predict_proba(X_base)
    y_prob_pol  = trained_model.predict_proba(X_policy)
    y_pred_base = y_prob_base.argmax(axis=1)
    y_pred_pol  = y_prob_pol.argmax(axis=1)

    # Ranking metric (macro OVR ROC AUC)
    auc_base = roc_auc_score(y_true, y_prob_base, multi_class="ovr", average="macro")
    auc_pol  = roc_auc_score(y_true, y_prob_pol,  multi_class="ovr", average="macro")

    print(f"\n== {label} ==")
    print("Baseline ROC AUC:", auc_base)
    print("After Policy ROC AUC:", auc_pol)
    print("Δ AUC:", auc_pol - auc_base)

    # Transition matrix (% within baseline row)
    trans = (
        pd.crosstab(
            y_pred_base, y_pred_pol,
            rownames=["Predicted (Baseline)"],
            colnames=[f"Predicted ({label})"],
            normalize="index",
        )
        * 100
    )
    print("\nTransition matrix (%):")
    print(trans.round(1))

    # Post-policy classification report (vs. y_true)
    print("\nClassification Report (after policy):\n",
          classification_report(y_true, y_pred_pol, digits=3))

    return {"auc_base": auc_base, "auc_policy": auc_pol, "trans": trans}


# ------------------------------------------------------------
# [Viz] Heatmap (Transition Matrix, Blues)
# ------------------------------------------------------------
def plot_transition_heatmap(trans_df, title="Transition Matrix"):
    """
    Visualize class transition matrix: Predicted (Before) → Predicted (After).
    """
    labels = sorted(list(set(trans_df.index) | set(trans_df.columns)))
    trans_df = trans_df.reindex(index=labels, columns=labels, fill_value=0.0)
    mat = trans_df.values  # percentages

    fig, ax = plt.subplots(figsize=(5.8, 4.8))
    im = ax.imshow(mat, cmap="Blues", aspect="auto", vmin=0, vmax=100)

    ax.set_title(title)
    ax.set_xlabel("Predicted (After)")
    ax.set_ylabel("Predicted (Before)")
    ax.set_xticks(np.arange(len(labels)))
    ax.set_yticks(np.arange(len(labels)))
    ax.set_xticklabels(labels)
    ax.set_yticklabels(labels)

    # overlay cell values
    for i in range(mat.shape[0]):
        for j in range(mat.shape[1]):
            val = mat[i, j]
            ax.text(
                j, i, f"{val:.1f}",
                ha="center", va="center",
                color=("white" if val > 50 else "black"),
                fontsize=9,
            )

    cbar = plt.colorbar(im)
    cbar.set_label("% within row", rotation=90)
    plt.tight_layout()
    plt.show()


# ============================================================
# Run policies (examples)
# Assumes: X_test (features), y_test (true labels), model (trained classifier)
# ============================================================

# Policy 1: Uniform Cash (¥100,000 ≈ +0.02)
X_test_uniform = apply_uniform_cash_policy(
    X_test, income_col="annual_income", amount=UNIFORM_AMOUNT, per_capita=False
)
res_uniform = eval_policy_shift(model, X_test, X_test_uniform, y_test, label="Uniform Cash")
plot_transition_heatmap(res_uniform["trans"], "Uniform Cash – Transition Matrix")

# Policy 2: Targeted Cash (Bottom 30%, ¥100,000 to recipients)
X_test_targeted = apply_targeted_cash_policy(
    X_test, income_col="annual_income", amount=UNIFORM_AMOUNT, quantile=TARGET_QUANTILE
)
res_targeted = eval_policy_shift(model, X_test, X_test_targeted, y_test, label="Targeted Cash (Bottom 30%)")
plot_transition_heatmap(res_targeted["trans"], "Targeted Cash (Bottom 30%) – Transition Matrix")

# Policy 3: Budget-Neutral Targeted Cash (same total budget as uniform)
X_test_targeted_bn = apply_budget_neutral_targeted_cash(
    X_test, income_col="annual_income", uniform_amount=UNIFORM_AMOUNT, quantile=TARGET_QUANTILE
)
res_targeted_bn = eval_policy_shift(model, X_test, X_test_targeted_bn, y_test, label="Targeted Cash (Budget Neutral)")
plot_transition_heatmap(res_targeted_bn["trans"], "Targeted Cash (Budget Neutral) – Transition Matrix")

  # ============================================================
# [Cell] Compare 4 Scenarios Side by Side (Shock + 3 Policies, no colorbar)
# ============================================================
import matplotlib.pyplot as plt
import numpy as np

matrices = {
    "Shock": trans_mat,
    "Uniform": res_uniform["trans"],
    "Targeted": res_targeted["trans"],
    "Budget-Neutral": res_targeted_bn["trans"]
}

all_labels = sorted(
    list(
        set().union(
            *[set(df.index) | set(df.columns) for df in matrices.values()]
        )
    )
)

fig, axes = plt.subplots(1, 4, figsize=(20, 5))

for ax, (title, trans_df) in zip(axes, matrices.items()):
    trans_df = trans_df.reindex(index=all_labels, columns=all_labels, fill_value=0.0)
    mat = trans_df.values

    im = ax.imshow(mat, cmap="Blues", aspect="auto", vmin=0, vmax=100)
    ax.set_title(title, fontsize=11)
    ax.set_xlabel("Predicted (After)")
    if title == "Shock":
        ax.set_ylabel("Predicted (Before)")
    else:
        ax.set_yticks([])

    ax.set_xticks(np.arange(len(all_labels)))
    ax.set_xticklabels(all_labels, rotation=45, ha="right")
    ax.set_yticks(np.arange(len(all_labels)))
    if title == "Shock":
        ax.set_yticklabels(all_labels)
    else:
        ax.set_yticklabels([])

    for i in range(mat.shape[0]):
        for j in range(mat.shape[1]):
            val = mat[i, j]
            ax.text(j, i, f"{val:.1f}", ha="center", va="center",
                    color=("white" if val > 50 else "black"), fontsize=7)

# Removed colorbar completely
plt.suptitle("Comparison of Shock and Policy Scenarios – Transition Matrices", fontsize=13)
plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.show()
